diff --git a/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m b/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m
index 1234567..abcdefg 100644
--- a/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m
+++ b/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m
@@ -76,7 +76,7 @@
     GLKView *view = [[GLKView alloc] initWithFrame:self.bounds];
     view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
     view.translatesAutoresizingMaskIntoConstraints = YES;
     view.context = self.context;
-    view.contentScaleFactor = 1.0f;
+    view.contentScaleFactor = [UIScreen mainScreen].scale;
     view.drawableDepthFormat = GLKViewDrawableDepthFormat24;
     [self insertSubview:view atIndex:0];
     _glkView = view;
@@ -115,7 +115,16 @@

     NSError *error = nil;
     AVCaptureDeviceInput* input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&error];
-    session.sessionPreset = AVCaptureSessionPresetPhoto;
+
+    // Try to use the highest quality preset available
+    if ([session canSetSessionPreset:AVCaptureSessionPreset3840x2160]) {
+        session.sessionPreset = AVCaptureSessionPreset3840x2160; // 4K
+    } else if ([session canSetSessionPreset:AVCaptureSessionPreset1920x1080]) {
+        session.sessionPreset = AVCaptureSessionPreset1920x1080; // Full HD
+    } else {
+        session.sessionPreset = AVCaptureSessionPresetPhoto; // Fallback
+    }
+
     [session addInput:input];

     AVCaptureVideoDataOutput *dataOutput = [[AVCaptureVideoDataOutput alloc] init];
@@ -134,6 +143,8 @@
     [session addOutput:dataOutput];

     self.stillImageOutput = [[AVCaptureStillImageOutput alloc] init];
+    // Use maximum quality for still image capture
+    self.stillImageOutput.outputSettings = @{AVVideoCodecKey: AVVideoCodecJPEG};
     [session addOutput:self.stillImageOutput];

     AVCaptureConnection *connection = [dataOutput.connections firstObject];
@@ -381,10 +392,18 @@

     [self.stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler: ^(CMSampleBufferRef imageSampleBuffer, NSError *error)
      {
-         NSData *imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageSampleBuffer];
+         // Get the highest quality image data from sample buffer
+         CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(imageSampleBuffer);
+         CIImage *sourceImage = [CIImage imageWithCVPixelBuffer:imageBuffer];
+
+         // Create high quality JPEG data
+         CIContext *context = [CIContext context];
+         NSData *imageData = [context JPEGRepresentationOfImage:sourceImage colorSpace:sourceImage.colorSpace options:@{(id)kCGImageDestinationLossyCompressionQuality: @(0.95)}];

          if (weakSelf.cameraViewType == IPDFCameraViewTypeBlackAndWhite || weakSelf.isBorderDetectionEnabled)
          {
-             CIImage *enhancedImage = [CIImage imageWithData:imageData];
+             // Use source image directly for better quality
+             CIImage *enhancedImage = sourceImage;

              if (weakSelf.cameraViewType == IPDFCameraViewTypeBlackAndWhite)
              {
@@ -405,10 +424,17 @@
                  {
                      enhancedImage = [self correctPerspectiveForImage:enhancedImage withFeatures:rectangleFeature];

-                    UIGraphicsBeginImageContext(CGSizeMake(enhancedImage.extent.size.height, enhancedImage.extent.size.width));
-                    [[UIImage imageWithCIImage:enhancedImage scale:1.0 orientation:UIImageOrientationRight] drawInRect:CGRectMake(0,0, enhancedImage.extent.size.height, enhancedImage.extent.size.width)];
-                    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
-                    UIImage *initialImage = [UIImage imageWithData:imageData];
-                    UIGraphicsEndImageContext();
+                     // Convert CIImage to UIImage with high quality using CIContext
+                     CIContext *ciContext = [CIContext contextWithOptions:@{kCIContextUseSoftwareRenderer: @(NO)}];
+
+                     // Apply rotation to match device orientation
+                     CGAffineTransform transform = CGAffineTransformMakeRotation(-M_PI_2);
+                     enhancedImage = [enhancedImage imageByApplyingTransform:transform];
+
+                     // Convert to CGImage first for better quality
+                     CGImageRef cgImage = [ciContext createCGImage:enhancedImage fromRect:enhancedImage.extent];
+                     UIImage *image = [UIImage imageWithCGImage:cgImage scale:1.0 orientation:UIImageOrientationUp];
+                     CGImageRelease(cgImage);
+
+                     UIImage *initialImage = [UIImage imageWithData:imageData];

                      [weakSelf hideGLKView:NO completion:nil];
