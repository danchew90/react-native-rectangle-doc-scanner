diff --git a/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m b/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m
index 1234567..abcdefg 100644
--- a/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m
+++ b/node_modules/react-native-document-scanner/ios/IPDFCameraViewController.m
@@ -76,7 +76,7 @@
     GLKView *view = [[GLKView alloc] initWithFrame:self.bounds];
     view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
     view.translatesAutoresizingMaskIntoConstraints = YES;
     view.context = self.context;
-    view.contentScaleFactor = 1.0f;
+    view.contentScaleFactor = [UIScreen mainScreen].scale;
     view.drawableDepthFormat = GLKViewDrawableDepthFormat24;
     [self insertSubview:view atIndex:0];
     _glkView = view;
@@ -115,7 +115,16 @@

     NSError *error = nil;
     AVCaptureDeviceInput* input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&error];
-    session.sessionPreset = AVCaptureSessionPresetPhoto;
+
+    // Try to use the highest quality preset available
+    if ([session canSetSessionPreset:AVCaptureSessionPreset3840x2160]) {
+        session.sessionPreset = AVCaptureSessionPreset3840x2160; // 4K
+    } else if ([session canSetSessionPreset:AVCaptureSessionPreset1920x1080]) {
+        session.sessionPreset = AVCaptureSessionPreset1920x1080; // Full HD
+    } else {
+        session.sessionPreset = AVCaptureSessionPresetPhoto; // Fallback
+    }
+
     [session addInput:input];

     AVCaptureVideoDataOutput *dataOutput = [[AVCaptureVideoDataOutput alloc] init];
@@ -134,23 +143,70 @@
     [session addOutput:dataOutput];

     self.stillImageOutput = [[AVCaptureStillImageOutput alloc] init];
+    // Configure for maximum quality still image capture
+    self.stillImageOutput.outputSettings = @{AVVideoCodecKey: AVVideoCodecJPEG};
+    self.stillImageOutput.highResolutionStillImageOutputEnabled = YES;
     [session addOutput:self.stillImageOutput];

     AVCaptureConnection *connection = [dataOutput.connections firstObject];
     [connection setVideoOrientation:AVCaptureVideoOrientationPortrait];

-    if (device.isFlashAvailable)
+    // Enable video stabilization for better quality
+    if ([connection isVideoStabilizationSupported]) {
+        [connection setPreferredVideoStabilizationMode:AVCaptureVideoStabilizationModeAuto];
+    }
+
+    // Configure device for best quality
+    if ([device lockForConfiguration:nil])
     {
-        [device lockForConfiguration:nil];
-        [device setFlashMode:AVCaptureFlashModeOff];
-        [device unlockForConfiguration];
+        // Disable flash for better natural lighting
+        if (device.isFlashAvailable) {
+            [device setFlashMode:AVCaptureFlashModeOff];
+        }

-        if ([device isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus])
-        {
-            [device lockForConfiguration:nil];
+        // Enable continuous autofocus for sharp images
+        if ([device isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) {
             [device setFocusMode:AVCaptureFocusModeContinuousAutoFocus];
-            [device unlockForConfiguration];
         }
+
+        // Enable continuous auto exposure
+        if ([device isExposureModeSupported:AVCaptureExposureModeContinuousAutoExposure]) {
+            [device setExposureMode:AVCaptureExposureModeContinuousAutoExposure];
+        }
+
+        // Enable auto white balance
+        if ([device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance]) {
+            [device setWhiteBalanceMode:AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance];
+        }
+
+        // Enable low light boost if available
+        if (device.isLowLightBoostSupported) {
+            [device setAutomaticallyEnablesLowLightBoostWhenAvailable:YES];
+        }
+
+        // Set active video format to highest resolution
+        if (@available(iOS 13.0, *)) {
+            AVCaptureDeviceFormat *bestFormat = nil;
+            AVFrameRateRange *bestFrameRateRange = nil;
+            for (AVCaptureDeviceFormat *format in [device formats]) {
+                CMVideoDimensions dimensions = CMVideoFormatDescriptionGetDimensions(format.formatDescription);
+                // Prefer 4K resolution (3840x2160)
+                if (dimensions.width == 3840 && dimensions.height == 2160) {
+                    for (AVFrameRateRange *range in format.videoSupportedFrameRateRanges) {
+                        if (bestFormat == nil || range.maxFrameRate > bestFrameRateRange.maxFrameRate) {
+                            bestFormat = format;
+                            bestFrameRateRange = range;
+                        }
+                    }
+                }
+            }
+            if (bestFormat) {
+                [device setActiveFormat:bestFormat];
+            }
+        }
+
+        [device unlockForConfiguration];
     }

     [session commitConfiguration];
@@ -381,10 +437,18 @@

     [self.stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler: ^(CMSampleBufferRef imageSampleBuffer, NSError *error)
      {
-         NSData *imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageSampleBuffer];
+         // Get the highest quality image data from sample buffer
+         CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(imageSampleBuffer);
+         CIImage *sourceImage = [CIImage imageWithCVPixelBuffer:imageBuffer];
+
+         // Create high quality JPEG data
+         CIContext *context = [CIContext context];
+         NSData *imageData = [context JPEGRepresentationOfImage:sourceImage colorSpace:sourceImage.colorSpace options:@{(id)kCGImageDestinationLossyCompressionQuality: @(0.95)}];

          if (weakSelf.cameraViewType == IPDFCameraViewTypeBlackAndWhite || weakSelf.isBorderDetectionEnabled)
          {
-             CIImage *enhancedImage = [CIImage imageWithData:imageData];
+             // Use source image directly for better quality
+             CIImage *enhancedImage = sourceImage;

              if (weakSelf.cameraViewType == IPDFCameraViewTypeBlackAndWhite)
              {
@@ -405,10 +469,17 @@
                  {
                      enhancedImage = [self correctPerspectiveForImage:enhancedImage withFeatures:rectangleFeature];

-                    UIGraphicsBeginImageContext(CGSizeMake(enhancedImage.extent.size.height, enhancedImage.extent.size.width));
-                    [[UIImage imageWithCIImage:enhancedImage scale:1.0 orientation:UIImageOrientationRight] drawInRect:CGRectMake(0,0, enhancedImage.extent.size.height, enhancedImage.extent.size.width)];
-                    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
-                    UIImage *initialImage = [UIImage imageWithData:imageData];
-                    UIGraphicsEndImageContext();
+                     // Convert CIImage to UIImage with high quality using CIContext
+                     CIContext *ciContext = [CIContext contextWithOptions:@{kCIContextUseSoftwareRenderer: @(NO)}];
+
+                     // Apply rotation to match device orientation
+                     CGAffineTransform transform = CGAffineTransformMakeRotation(-M_PI_2);
+                     enhancedImage = [enhancedImage imageByApplyingTransform:transform];
+
+                     // Convert to CGImage first for better quality
+                     CGImageRef cgImage = [ciContext createCGImage:enhancedImage fromRect:enhancedImage.extent];
+                     UIImage *image = [UIImage imageWithCGImage:cgImage scale:1.0 orientation:UIImageOrientationUp];
+                     CGImageRelease(cgImage);
+
+                     UIImage *initialImage = [UIImage imageWithData:imageData];

                      [weakSelf hideGLKView:NO completion:nil];
